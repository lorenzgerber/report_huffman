\documentclass[a4paper,11pt,twoside]{article}
%\documentclass[a4paper,11pt,twoside,se]{article}

\usepackage{UmUStudentReport}
\usepackage{verbatim}   % Multi-line comments using \begin{comment}
\usepackage{courier}    % Nicer fonts are used. (not necessary)
\usepackage{pslatex}    % Also nicer fonts. (not necessary)
\usepackage[pdftex]{graphicx}   % allows including pdf figures
\usepackage{listings}
%\usepackage{lmodern}   % Optional fonts. (not necessary)
%\usepackage{tabularx}
%\usepackage{microtype} % Provides some typographic improvements over default settings
%\usepackage{placeins}  % For aligning images with \FloatBarrier
%\usepackage{booktabs}  % For nice-looking tables
%\usepackage{titlesec}  % More granular control of sections.

% DOCUMENT INFO
% =============
\department{Institution för Datavetenskap}
\coursename{Datavetenskapens byggstenar 7.5 p}
\coursecode{DV160HT15}
\title{OU3 Huffman Coding}
\author{Simon Andersson ({\tt{dv15san@cs.umu.se}})}
\author{Lorenz Gerber ({\tt{dv15lgr@cs.umu.se}})} 
\date{2016-02-18}
%\revisiondate{2016-01-18}
\instructor{Lena Kallin Westin / Erik Moström / Jonathan Westin}


% DOCUMENT SETTINGS
% =================
\bibliographystyle{plain}
%\bibliographystyle{ieee}
\pagestyle{fancy}
\raggedbottom
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
%\graphicspath{{images/}}   %Path for images

\usepackage{float}
\floatstyle{ruled}
\newfloat{listing}{thp}{lop}
\floatname{listing}{Listing}


% DEFINES
% =======
%\newcommand{\mycommand}{<latex code>}

% DOCUMENT
% ========
\begin{document}
\lstset{language=C}
\maketitle
\thispagestyle{empty}

\tableofcontents
\newpage

\clearpage
\pagenumbering{arabic} 

\section{Introduction} 
The aim of this laboration was to plan and implement a command line
program written in C that accomplishes encoding and decoding of 
text files according to the \emph{Huffman} algorithm.

The \emph{Huffman} algoritm is used for data compression, in our case
for text files. The basic idea is that instead of using 8 bits for
every character, find unique variable length binary representations
for every character where the most common used characters get the
shortest binary sequences. In practice, this includes several steps:
First a frequency count table of all characters has to be
compiled. Then a binary tree is constructed where characters and their
count frequency as leafs. Characters with high frequency count will be
placed the closest to the tree root. A more detailed description of
this process will be given in the method description.



\section{Material and Methods}
\subsection{Datatypes}
From the provided datatypes we used \emph{prioqueue} (which is built on
\emph{list\_2cell}), \emph{tree\_3cell}, and \emph{bitset}. Aside from the provided 
datatypes another composite datatype, \emph{freqChar}, storing a character and associated frequency was
created. This datatype was the one stored as data in the Huffman tree.



\subsection{Work Organization}
On an initial kick-off meeting, we discussed the problem and possible
solution strategies. Then we created repositories for the 
\emph{\href{https://github.com/lorenzgerber/huffman}{code}} and for
the \emph{\href{https://github.com/lorenzgerber/report_huffman}{report}}
on \emph{\href{https://github.com}{github}} and setup a team in a 
workgroup messaging  app (\emph{\href{https://slack.com}{slack}}). All
further work and communication was done remote using the
afore-mentioned tools. 

\section{Results}
blablabla

\section{Program structure}
\subsection{Parameters}
This program takes four parameters from the command line. The first one determines whether the 
user wants to \emph{-encode} or \emph{-decode} the input file. The remaining three parameters represent 
three files where the first one is the file upon which the frequency analysis will be done, the second one is said 
input file and the third file is where the result will be saved. 

If user enters option \emph{-encode} the functions \emph{getFrequency}, \emph{buildHuffmanTree}, \emph{traverseTree}, and, \emph{encodeFile} will be called to encode the input file and save the result in the output file. If \emph{-decode} is sent as a parameter \emph{getFrequency}, \emph{buildHuffmanTree}, and, \emph{decodeFile} will be called to decode text in the input file and save the decoded text in output file. And lastly if the user were to give an incorrect option or if the files cannot be opened or in some way return errors the program will exit with an instruction on how to properly use the program.

\subsection{getFrequency}
In \emph{getFrequency}  frequencies for characters read from the frequency file are calculated.
All frequencies are stored in an array of size 256, enough to store every character in ASCII, where indexes 0 through 255 
represent the different symbols. Even though it is probably not read from the file the symbol with ASCII code 4 is given frequency 1. This is because this character is the \emph{end of transmission} sign which will be written during encoding no matter what text is encoded. Once the analysis is done every position with a frequency of 0 is set to 1 to avoid problems while
building the tree later on. To account for this \emph{real} frequencies are multiplied by 1000 to keep their priority over these artificial values.
\subsection{compareTrees}
This function is the function required by the \emph{prioqueue} to correctly enqueue and dequeue trees from the priority queue
The labels of two root nodes in two different binary trees is inspected. The frequency value in these two freqChars are compared and the tree with a lower value is given higher priority.
\subsection{buildHuffmanTree}
Now we have all the tools necessary to construct the Huffman tree. From the frequency array 256 trees are created 
each with a single node labeled with a freqChar struct storing one of 256 ASCII characters and the frequency value for that character. These trees are then enqueued into a priority queue using the \emph{compareTrees} function so that the trees with the lowest frequencies have the highest priority. 

Then two trees are dequeued and merged into a new tree with a root node storing the sum of frequencies of these two smaller trees. After this the new tree is enqueued again and the process repeats until only one tree remains in the queue. Every character now has its place in a single Huffman tree. The tree is complete and gets returned.
\subsection{traverseTree}
Once the tree is built we need to extract binary sequences for every character from it. This is done by using the \emph{traverseTree} function. 

\emph{traverseTree} is a recursive function performing a preorder traversal of a binary tree. In addition to the tree the function takes a binary tree position, an array to store bit sequences, and, an array containing pointers to 256 bitsets as parameters. The function will check if the current position in the tree has left and/or right children. If a left children exists a 0 will be written in the array and the function will make a recursive call with the position of this child. The procedure is the same if a right child exists except that a 1 is written in the array instead of a 0. Once a childless position is found the bit sequence is inserted into a bitset whose pointer is stored in the pointer array. 

\subsection{encodeFile}
\emph{encodeFile} is the function responsible for encoding the input file. This function will read a character from the input file . From the bit-set-pointer array the correct bitset is chosen. The bit sequence from this bitset is inserted into a new bitset which will store all bit sequences for the entire input file. Last in the sequence a \emph{end of transmission} sign is placed. Once every character has been read and stored as a bit sequence in the compound bitset the function will save the whole compound bitset in the output file.

\subsection{decodeFile}
In \emph{decodeFile} every symbol in the input file is read and converted back to binary sequence. This sequence is stored in a boolean-array as ones and zeros. The sequence is then used to wander through the tree. For every 1 read we move right and for every 0 we move left until a leaf is reached. Once we reached a leaf the character stored in that leaf's freqChar is read and written in the output file. When \emph{end of transmission} is reached the decoding ends.

\section{Discussion}
bla bla bla...

\section{Contributions}
Both authors were involved in every function with either writing or
debugging/checking it. The initials in table \ref{tab:contribution}
stand for the person who initially wrote the respective function.


\begin{table}[]
\centering
\caption{work contributionsn}
\label{tab:contribution}
\begin{tabular}{ll}
planning and defining the strategy & SAN, LGR \\
setting up and managing git repos  & LGR      \\
                                   &          \\
initial code structure             & SAN, LGR \\
main program and argument handling & LGR      \\
char frequency count               & SAN      \\
compare tree function              & SAN      \\
build Huffman tree                 & SAN      \\
tree traversal function            & SAN      \\
huffman code from tree traversal   & LGR      \\
encode function                    & LGR      \\
decode function                    & SAN, LGR \\
file read/write                    & LGR      \\
                                   &          \\
commenting and styling code        & SAN, LGR \\
memory leak check                  & SAN      \\
                                   &          \\
setting up LaTex document          & LGR      \\
writing report                     & SAN LGR  \\
                                   &         
\end{tabular}
\end{table}


\addcontentsline{toc}{section}{\refname}
\bibliography{references}

\end{document}
